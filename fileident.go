package main

import (
	"encoding/binary"
	"fmt"
	"os"
)

// FileType represents the type of executable file
type FileType int

const (
	FileTypeUnknown FileType = iota
	FileTypeELF
	FileTypeMachO
)

// FileInfo contains information about an executable file
type FileInfo struct {
	Type FileType
	Arch Arch
}

// IdentifyFile identifies the type and architecture of an executable file
// This replaces the need for the external "file" utility
func IdentifyFile(path string) (*FileInfo, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("failed to open file: %v", err)
	}
	defer f.Close()

	// Read first few bytes to check magic numbers
	header := make([]byte, 32)
	n, err := f.Read(header)
	if err != nil || n < 4 {
		return nil, fmt.Errorf("failed to read file header: %v", err)
	}

	info := &FileInfo{Type: FileTypeUnknown, Arch: ArchUnknown}

	// Check for ELF magic: 0x7F 'E' 'L' 'F'
	if n >= 4 && header[0] == 0x7F && header[1] == 'E' && header[2] == 'L' && header[3] == 'F' {
		info.Type = FileTypeELF

		// ELF architecture is at offset 18 (e_machine field)
		if n >= 20 {
			machine := binary.LittleEndian.Uint16(header[18:20])
			switch machine {
			case 0x3E: // EM_X86_64
				info.Arch = ArchX86_64
			case 0xB7: // EM_AARCH64
				info.Arch = ArchARM64
			case 0xF3: // EM_RISCV
				info.Arch = ArchRiscv64
			}
		}
		return info, nil
	}

	// Check for Mach-O magic numbers
	// Mach-O files generated by this compiler use little-endian byte order
	// MH_MAGIC_64 = 0xfeedfacf (64-bit)
	// MH_CIGAM_64 = 0xcffaedfe (byte-swapped 64-bit)
	// MH_MAGIC = 0xfeedface (32-bit)
	// MH_CIGAM = 0xcefaedfe (byte-swapped 32-bit)
	if n >= 4 {
		// Try reading as little-endian (what this compiler generates)
		magic := binary.LittleEndian.Uint32(header[0:4])

		isMachO := false
		switch magic {
		case 0xfeedfacf, 0xcffaedfe, 0xfeedface, 0xcefaedfe:
			isMachO = true
		}

		// Also try big-endian
		if !isMachO {
			magicBig := binary.BigEndian.Uint32(header[0:4])
			switch magicBig {
			case 0xfeedfacf, 0xcffaedfe, 0xfeedface, 0xcefaedfe:
				isMachO = true
				magic = magicBig
			}
		}

		if isMachO {
			info.Type = FileTypeMachO

			// CPU type is at offset 4 in Mach-O header
			// Use little-endian since that's what this compiler generates
			if n >= 8 {
				cputype := binary.LittleEndian.Uint32(header[4:8])

				// Mach-O CPU types
				// CPU_TYPE_X86_64 = 0x01000007
				// CPU_TYPE_ARM64 = 0x0100000c
				switch cputype {
				case 0x01000007:
					info.Arch = ArchX86_64
				case 0x0100000c:
					info.Arch = ArchARM64
				}
			}
			return info, nil
		}
	}

	return info, nil
}

// String returns a human-readable description of the file type
func (fi *FileInfo) String() string {
	var result string

	switch fi.Type {
	case FileTypeELF:
		result = "ELF"
	case FileTypeMachO:
		result = "Mach-O"
	default:
		result = "Unknown"
	}

	if fi.Arch != ArchUnknown {
		result += " " + fi.Arch.String()
	}

	return result
}

// IsELF returns true if the file is an ELF executable
func (fi *FileInfo) IsELF() bool {
	return fi.Type == FileTypeELF
}

// IsMachO returns true if the file is a Mach-O executable
func (fi *FileInfo) IsMachO() bool {
	return fi.Type == FileTypeMachO
}

// IsARM64 returns true if the file is ARM64 architecture
func (fi *FileInfo) IsARM64() bool {
	return fi.Arch == ArchARM64
}

// IsX86_64 returns true if the file is x86_64 architecture
func (fi *FileInfo) IsX86_64() bool {
	return fi.Arch == ArchX86_64
}
