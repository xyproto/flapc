// Sieve of Eratosthenes - find all primes up to N
// Demonstrates: loops, maps, mutable variables, mathematical algorithms

N := 100
sieve := map()

// Initialize: mark all numbers as potentially prime
@ i in 2..<N {
    sieve[i] = 1.0  // 1.0 = prime, 0.0 = composite
}

// Sieve algorithm: for each number, if prime, mark multiples as composite
@ i in 2..<N {
    // Skip if already marked as composite
    isPrime := sieve[i]

    // For each prime, mark all multiples as composite
    @ j in i..<N {
        // Only process if i is prime (isPrime == 1.0)
        // j is the multiplier: mark i*2, i*3, i*4, etc.
        (isPrime == 1.0 and i * j < N and j > 1) {
            sieve[i * j] = 0.0
        }
    }
}

// Count and display primes
primeCount := 0
@ i in 2..<N {
    sieve[i] == 1.0 {
        printf("%v ", i)
        primeCount = primeCount + 1
    }
}

printf("\nFound %v primes less than %v\n", primeCount, N)
