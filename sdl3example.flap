// sdl3example.flap - SDL3 Graphics Demo with Defer and Railway-Oriented Error Handling
//
// This example demonstrates:
//   1. SDL3 C FFI integration
//   2. Railway-oriented programming with or! operator for null pointer checking
//   3. Defer for automatic resource cleanup (LIFO order)
//   4. BMP image loading and display
//   5. Blocks that return values as expressions
//
// The or! operator checks for null pointers (0) from C functions and
// executes the error handling block if the pointer is null.
// Defer ensures cleanup happens automatically in reverse order.
//
// To compile and run:
//   ./flapc sdl3example.flap -o sdl3example
//   ./sdl3example
//
// Requires:
//   - SDL3 library installed (pkg-config sdl3)
//   - img/grumpy-cat.bmp file in the working directory

import sdl3 as sdl

// Window dimensions
width := 620
height := 387

//hai()

// Initialize SDL3 with video subsystem
println("Initializing SDL3...")

// SDL3 returns true (1) on success, false (0) on failure
// Use or! for railway-oriented error handling
// Note: Blocks that return values are expressions (no exit needed - defer handles cleanup)
sdl.SDL_Init(sdl.SDL_INIT_VIDEO) or! {
    //snubblidubblifoo()
    exitf("SDL_Init failed: %s\n", sdl.SDL_GetError())
}

// Use defer to ensure SDL_Quit is called when program exits
// Deferred calls execute in LIFO (Last In, First Out) order
defer sdl.SDL_Quit()

println("Creating window and renderer...")

// Create window - or! checks for null pointer (0) and returns error value if null
window := sdl.SDL_CreateWindow("Hello World!", width, height, sdl.SDL_WINDOW_RESIZABLE) or! {
    exitf("Failed to create window: %s\n", sdl.SDL_GetError())
}

// Defer window cleanup - will execute before SDL_Quit
defer sdl.SDL_DestroyWindow(window)

// Create renderer - clean error handling with or!
renderer := sdl.SDL_CreateRenderer(window, 0) or! {
    exitf("Failed to create renderer: %s\n", sdl.SDL_GetError())
}

// Defer renderer cleanup - will execute before window cleanup
defer sdl.SDL_DestroyRenderer(renderer)

printf("Loading BMP image...\n")

// Load BMP file - or! handles null file pointer
file := sdl.SDL_IOFromFile("img/grumpy-cat.bmp", "rb") or! {
    exitf("Error reading file: %s\n", sdl.SDL_GetError())
}

// Load BMP surface from file
bmp := sdl.SDL_LoadBMP_IO(file, 1) or! {
    exitf("Error creating surface: %s\n", sdl.SDL_GetError())
}

// Defer surface cleanup
defer sdl.SDL_DestroySurface(bmp)

// Create texture from surface
tex := sdl.SDL_CreateTextureFromSurface(renderer, bmp) or! {
    exitf("Error creating texture: %s\n", sdl.SDL_GetError())
}

// Defer texture cleanup - will execute first (LIFO)
defer sdl.SDL_DestroyTexture(tex)

println("Rendering for 2 seconds...")

// Main rendering loop - run for approximately 2 seconds (20 frames * 100ms = 2s)
@ frame in 0..<20 {
    // Clear screen
    sdl.SDL_RenderClear(renderer)

    // Render texture (fills entire window)
    sdl.SDL_RenderTexture(renderer, tex, 0, 0)

    // Present the rendered frame
    sdl.SDL_RenderPresent(renderer)

    // Delay to maintain framerate
    sdl.SDL_Delay(100)
}

println("Done!")

// All cleanup happens automatically via defer in this order:
// 1. SDL_DestroyTexture(tex)
// 2. SDL_DestroySurface(bmp)
// 3. SDL_DestroyRenderer(renderer)
// 4. SDL_DestroyWindow(window)
// 5. SDL_Quit()

// NOTE: Defer, Arena Allocators, and C FFI
//
// This example demonstrates the power of defer for resource management:
//   - Resources are cleaned up in LIFO order automatically
//   - No need for manual cleanup code or exit() calls
//   - Error handling blocks can simply return, defer handles cleanup
//   - Cleaner code that's easier to maintain
//
// Arena Allocators vs Defer:
//   - Defer: For C FFI resources (SDL windows, files, etc.) - manual order
//   - Arena: For Flap-managed memory (lists, maps, strings) - bulk deallocation
//
// Why arena can't manage C library pointers:
//   - C libraries expect their own allocation/deallocation functions
//   - Arena memory is bulk-freed at scope exit, breaking C library invariants
//   - SDL_DestroyWindow, SDL_DestroyRenderer, etc. must be called in proper order
//
// Best practices for C FFI:
//   1. Use or! for railway-oriented null pointer checking (shown above)
//   2. Use defer for C resources in reverse order of allocation
//   3. Use arenas for Flap data structures within your program
//   4. Return from error blocks instead of exit() - defer handles cleanup
//
// Example combining defer with arena for Flap data:
//   defer c_cleanup()
//   arena {
//       data := [1, 2, 3, 4, 5]  // Allocated in arena
//       processed := data | x -> x * 2
//       result := processed | x -> x + 1
//       // All Flap allocations freed here (arena)
//   }
//   // C cleanup happens here (defer)
//
// Blocks that return values as expressions:
//   In the error handling blocks above, we use "ret 1" instead of "exit(1)".
//   This is because blocks that return values are valid expressions.
//   When used with or!, the block's return value becomes the fallback value.
//   Combined with defer, this means cleanup always happens, even on errors.
