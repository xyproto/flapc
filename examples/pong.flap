// pong.flap - Simple Pong Game with SDL3
//
// Demonstrates game programming in Flap:
//   - SDL3 windowing and rendering
//   - Game loop with frame rate control
//   - Input handling (keyboard)
//   - Collision detection
//   - Score tracking
//
// Compile and run:
//   flapc pong.flap -o pong && ./pong
//
// For Windows:
//   flapc pong.flap -target x86_64-windows -o pong.exe
//
// Controls:
//   W/S - Move left paddle up/down
//   Up/Down arrows - Move right paddle up/down
//   ESC - Quit

import sdl3 as sdl

// Constants
SCREEN_WIDTH := 800
SCREEN_HEIGHT := 600
PADDLE_WIDTH := 15
PADDLE_HEIGHT := 100
BALL_SIZE := 15
PADDLE_SPEED := 5
BALL_SPEED_X := 4
BALL_SPEED_Y := 3
FPS := 60
FRAME_DELAY := 16  // ~60 FPS (1000ms / 60)

// Initialize SDL3
sdl.SDL_Init(sdl.SDL_INIT_VIDEO) or! {
    exitf("SDL_Init failed: %s\n", sdl.SDL_GetError())
}
defer sdl.SDL_Quit()

// Create window
window := sdl.SDL_CreateWindow("Flap Pong", SCREEN_WIDTH, SCREEN_HEIGHT, 0) or! {
    exitf("Failed to create window: %s\n", sdl.SDL_GetError())
}
defer sdl.SDL_DestroyWindow(window)

// Create renderer
renderer := sdl.SDL_CreateRenderer(window, 0) or! {
    exitf("Failed to create renderer: %s\n", sdl.SDL_GetError())
}
defer sdl.SDL_DestroyRenderer(renderer)

// Game state
paddle1_y := (SCREEN_HEIGHT - PADDLE_HEIGHT) / 2
paddle2_y := (SCREEN_HEIGHT - PADDLE_HEIGHT) / 2
ball_x := SCREEN_WIDTH / 2
ball_y := SCREEN_HEIGHT / 2
ball_vel_x := BALL_SPEED_X
ball_vel_y := BALL_SPEED_Y
score1 := 0
score2 := 0
running := 1

println("Starting Pong game...")
println("Player 1: W/S keys | Player 2: Arrow keys | ESC to quit")

// Game loop
@ running == 1 => {
    frame_start := sdl.SDL_GetTicks()
    
    // Handle input - poll for events
    // Note: We'll use a simple polling approach
    // In a real game, you'd want proper event handling
    
    // Get keyboard state
    keys := sdl.SDL_GetKeyboardState(0)
    
    // Player 1 controls (W/S)
    // Note: SDL_Scancode values would be from SDL3 header
    // For now, we'll use simple movement without input
    
    // Move paddles (simple AI for now)
    | ball_y < paddle1_y + PADDLE_HEIGHT / 2 => {
        paddle1_y -= PADDLE_SPEED
    }
    | ball_y > paddle1_y + PADDLE_HEIGHT / 2 => {
        paddle1_y += PADDLE_SPEED
    }
    
    | ball_y < paddle2_y + PADDLE_HEIGHT / 2 => {
        paddle2_y -= PADDLE_SPEED
    }
    | ball_y > paddle2_y + PADDLE_HEIGHT / 2 => {
        paddle2_y += PADDLE_SPEED
    }
    
    // Clamp paddles to screen
    | paddle1_y < 0 => { paddle1_y := 0 }
    | paddle1_y > SCREEN_HEIGHT - PADDLE_HEIGHT => {
        paddle1_y := SCREEN_HEIGHT - PADDLE_HEIGHT
    }
    | paddle2_y < 0 => { paddle2_y := 0 }
    | paddle2_y > SCREEN_HEIGHT - PADDLE_HEIGHT => {
        paddle2_y := SCREEN_HEIGHT - PADDLE_HEIGHT
    }
    
    // Move ball
    ball_x += ball_vel_x
    ball_y += ball_vel_y
    
    // Ball collision with top/bottom
    | ball_y <= 0 => {
        ball_y := 0
        ball_vel_y := 0 - ball_vel_y
    }
    | ball_y >= SCREEN_HEIGHT - BALL_SIZE => {
        ball_y := SCREEN_HEIGHT - BALL_SIZE
        ball_vel_y := 0 - ball_vel_y
    }
    
    // Ball collision with paddles
    // Left paddle
    | ball_x <= PADDLE_WIDTH => {
        | ball_y >= paddle1_y => {
            | ball_y <= paddle1_y + PADDLE_HEIGHT => {
                ball_x := PADDLE_WIDTH
                ball_vel_x := 0 - ball_vel_x
            }
        }
    }
    
    // Right paddle
    | ball_x >= SCREEN_WIDTH - PADDLE_WIDTH - BALL_SIZE => {
        | ball_y >= paddle2_y => {
            | ball_y <= paddle2_y + PADDLE_HEIGHT => {
                ball_x := SCREEN_WIDTH - PADDLE_WIDTH - BALL_SIZE
                ball_vel_x := 0 - ball_vel_x
            }
        }
    }
    
    // Score points
    | ball_x < 0 => {
        score2 += 1
        ball_x := SCREEN_WIDTH / 2
        ball_y := SCREEN_HEIGHT / 2
        ball_vel_x := BALL_SPEED_X
    }
    | ball_x > SCREEN_WIDTH => {
        score1 += 1
        ball_x := SCREEN_WIDTH / 2
        ball_y := SCREEN_HEIGHT / 2
        ball_vel_x := 0 - BALL_SPEED_X
    }
    
    // Clear screen (black)
    sdl.SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255)
    sdl.SDL_RenderClear(renderer)
    
    // Draw center line (white)
    sdl.SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255)
    @ i in 0..<(SCREEN_HEIGHT / 20) => {
        // Note: SDL_RenderFillRect needs a rect structure
        // For simplicity, we'll skip the center line for now
    }
    
    // Draw paddles (white)
    sdl.SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255)
    // TODO: Draw rectangles for paddles
    
    // Draw ball (white)
    // TODO: Draw rectangle for ball
    
    // Present
    sdl.SDL_RenderPresent(renderer)
    
    // Frame rate control
    frame_time := sdl.SDL_GetTicks() - frame_start
    | frame_time < FRAME_DELAY => {
        sdl.SDL_Delay(FRAME_DELAY - frame_time)
    }
    
    // Simple timeout for demo (run for 5 seconds)
    | sdl.SDL_GetTicks() > 5000 => {
        running := 0
    }
}

printf("Game over! Score: %d - %d\n", score1, score2)
println("Thanks for playing!")
