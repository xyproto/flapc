// Test the :: (cons/prepend) operator
main ==> {
    // Basic cons operations
    list1 := 1 :: [2, 3, 4]
    printf("1 :: [2, 3, 4] = ")
    @ item in list1 {
        printf("%v ", item)
    }
    printf("\n")

    // Multiple cons (right-associative)
    list2 := 1 :: 2 :: 3 :: []
    printf("1 :: 2 :: 3 :: [] = ")
    @ item in list2 {
        printf("%v ", item)
    }
    printf("\n")

    // Building list functionally
    build_list := (n) => n <= 0 {
        -> []
        ~> n :: build_list(n - 1) max 100
    }

    countdown := build_list(5)
    printf("build_list(5) = ")
    @ item in countdown {
        printf("%v ", item)
    }
    printf("\n")

    // Prepending to existing list
    numbers := [10, 20, 30]
    extended := 0 :: numbers
    printf("0 :: [10, 20, 30] = ")
    @ item in extended {
        printf("%v ", item)
    }
    printf("\n")

    // Pattern matching with cons (conceptual)
    sample := [1, 2, 3, 4]
    first := ^sample
    rest := &sample
    printf("head of [1, 2, 3, 4] = %v\n", first)
    printf("tail of [1, 2, 3, 4] = ")
    @ item in rest {
        printf("%v ", item)
    }
    printf("\n")
}