// Test piping blocks to functions
main ==> {
    // Simulate FLAPGAME-style API
    printf("=== Piping Blocks Test ===\n\n")

    // Traditional style: explicit lambda
    execute_callback := (callback) => {
        printf("Executing callback...\n")
        callback()
    }

    printf("Traditional style:\n")
    execute_callback(() => {
        printf("  Inside callback!\n")
    })

    // Pipe style: block flows into function
    printf("\nPipe style (functional):\n")
    { printf("  Inside callback with pipe syntax!\n") } | execute_callback

    // With named function taking callback
    on_event := (name, handler) => {
        printf("Event '%v' triggered\n", name)
        handler()
    }

    printf("\nWith arguments (using explicit lambda):\n")
    on_event("click", () => {
        printf("  Button was clicked!\n")
    })

    // Conditional execution with blocks
    execute_if := (condition, action) => {
        condition {
            -> action()
            ~> printf("  Condition was false\n")
        }
    }

    printf("\nConditional execution:\n")
    execute_if(1, () => {
        printf("  Condition was true!\n")
    })

    execute_if(0, () => {
        printf("  This won't print\n")
    })

    // Game-style input handling simulation
    key_pressed := 1

    printf("\nGame-style pattern:\n")
    on_key_down := (key, action) => {
        key_pressed {
            -> {
                printf("Key '%v' pressed: ", key)
                action()
            }
        }
    }

    // Using pipe for callbacks
    printf("\nPipe-based handlers:\n")
    { printf("Jump!\n") } | on_key_down("space")
    { printf("Move forward!\n") } | on_key_down("w")

    printf("\n=== Test Complete ===\n")
}