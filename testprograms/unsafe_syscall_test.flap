// Simple syscall test - write "Hi!\n" to stdout using raw bytes

// Write to stdout using syscall (x86-64: sys_write = 1)
result := unsafe {
    rax <- 1                    // syscall number: write
    rdi <- 1                    // fd: stdout
    // We need a data address - use stack
    rsp <- rsp - 16             // Make space on stack
    rbx <- 0x0A214948           // "Hi!\n" in little endian: 'H', 'i', '!', '\n'
    [rsp] <- rbx                // Store to stack
    rsi <- rsp                  // buffer = stack pointer
    rdx <- 4                    // count: 4 bytes
    syscall                     // Emit syscall
    rsp <- rsp + 16             // Clean up stack
    // Return value in rax
} {
    x8 <- 64                    // ARM64: sys_write = 64
    x0 <- 1                     // fd: stdout
    sp <- sp - 16
    x1 <- 0x0A214948
    [sp] <- x1
    x2 <- sp
    x3 <- 4
    syscall
    sp <- sp + 16
    rax <- x0
} {
    a7 <- 64                    // RISC-V: sys_write = 64
    a0 <- 1                     // fd: stdout
    sp <- sp - 16
    a1 <- 0x0A214948
    [sp] <- a1
    a2 <- sp
    a3 <- 4
    syscall
    sp <- sp + 16
    rax <- a0
}

printf("Syscall returned: %.0f bytes\n", result)

exit(0)
